; proc _start() : long
_ = Call print(Start\n, 6)
_ = i Assign 0
Jump .T2
.T1:
<>T4 = PreIncrement i
.T2:
<>T5 = i ComparisonLessThan 100000
If !<>T5 Jump .T3
_ = Call arrAlloc(10)
Jump .T1
.T3:
_ = size Assign 10
<>T6 = Call arrInit(size)
_ = arr Assign <>T6
_ = seed Assign 14214
_ = i Assign 0
Jump .T8
.T7:
<>T10 = PreIncrement i
.T8:
<>T11 = i ComparisonLessThan size
If !<>T11 Jump .T9
<>T12 = Call pseudoRandom(seed)
_ = seed Assign <>T12
<>T13 = Call arrIndex(arr, i)
<>T15 = size Multiply 2
<>T14 = seed Remainder <>T15
_ = <>T13 ReferenceAssign <>T14
Jump .T7
.T9:
_ = Call printArr(arr, size)
_ = Call print(\n, 1)
_ = Call quickSort(arr, size)
_ = Call printArr(arr, size)
_ = Call arrFree(arr)

; proc pseudoRandom(seed : long) : long
<>T17 = seed Multiply 94813
<>T16 = <>T17 Remainder 42133
Return <>T16

; proc quickSort(arr : ptr, size : long) : long
<>T19 = size Subtract 1
<>T18 = Call quickSortCore(arr, 0, <>T19)
Return <>T18

; proc quickSortCore(arr : ptr, lo : long, hi : long) : long
<>T20 = lo ComparisonGreaterThanOrEqual hi
If <>T20 Jump .T21
Jump .T22
.T21:
Return 0
.T22:
<>T23 = Call partition(arr, lo, hi)
_ = partition Assign <>T23
<>T24 = partition Subtract 1
_ = Call quickSortCore(arr, lo, <>T24)
<>T25 = partition Add 1
_ = Call quickSortCore(arr, <>T25, hi)

; proc partition(arr : ptr, lo : long, hi : long) : long
<>T27 = Call arrIndex(arr, hi)
<>T26 = Dereference <>T27
_ = pivot Assign <>T26
_ = i Assign lo
_ = j Assign lo
Jump .T29
.T28:
<>T31 = PreIncrement j
.T29:
<>T32 = j ComparisonLessThanOrEqual hi
If !<>T32 Jump .T30
<>T34 = Call arrIndex(arr, j)
<>T33 = Dereference <>T34
_ = elem Assign <>T33
<>T35 = elem ComparisonLessThan pivot
If <>T35 Jump .T36
Jump .T37
.T36:
<>T38 = Call arrIndex(arr, j)
<>T40 = Call arrIndex(arr, i)
<>T39 = Dereference <>T40
_ = <>T38 ReferenceAssign <>T39
<>T41 = Call arrIndex(arr, i)
_ = <>T41 ReferenceAssign elem
<>T42 = i Add 1
_ = i Assign <>T42
.T37:
Jump .T28
.T30:
<>T43 = Call arrIndex(arr, hi)
<>T45 = Call arrIndex(arr, i)
<>T44 = Dereference <>T45
_ = <>T43 ReferenceAssign <>T44
<>T46 = Call arrIndex(arr, i)
_ = <>T46 ReferenceAssign pivot
Return i

; proc arrInit(size : long) : ptr
<>T47 = Call arrAlloc(size)
_ = arr Assign <>T47
_ = i Assign 0
Jump .T49
.T48:
<>T51 = PreIncrement i
.T49:
<>T52 = i ComparisonLessThan size
If !<>T52 Jump .T50
<>T53 = Call arrIndex(arr, i)
_ = <>T53 ReferenceAssign 0
Jump .T48
.T50:
Return arr

; proc arrFree(arr : ptr) : long
<>T54 = Call free(arr)
Return <>T54

; proc printArr(arr : ptr, size : long) : long
_ = i Assign 0
Jump .T56
.T55:
<>T58 = PreIncrement i
.T56:
<>T59 = i ComparisonLessThan size
If !<>T59 Jump .T57
<>T60 = i ComparisonGreaterThan 0
If <>T60 Jump .T61
Jump .T62
.T61:
_ = Call print(, , 2)
.T62:
<>T64 = Call arrIndex(arr, i)
<>T63 = Dereference <>T64
_ = Call printNum(<>T63)
Jump .T55
.T57:

; proc arrSize(arr : ptr) : long
<>T67 = ArithmeticNegation 1
<>T66 = Call arrIndex(arr, <>T67)
<>T65 = Dereference <>T66
Return <>T65

; proc arrAlloc(size : long) : ptr
<>T69 = size Multiply 8
<>T68 = Call alloc(<>T69)
Return <>T68

; proc arrIndex(arr : ptr, index : long) : ptr
<>T71 = arr Add 7
<>T72 = 8 Multiply index
<>T70 = <>T71 Add <>T72
Return <>T70

; proc alloc(size : long) : ptr
<>T73 = Call GetProcessHeap()
_ = heapHandle Assign <>T73
<>T74 = Call HeapAlloc(heapHandle, 0, size)
Return <>T74

; proc free(position : ptr) : bool
<>T75 = Call GetProcessHeap()
_ = heapHandle Assign <>T75
<>T76 = Call HeapFree(heapHandle, 0, position)
Return <>T76

; proc printNum(num : long) : long
<>T77 = Call printNumAny(num, 10)
Return <>T77

; proc printNumAny(num : long, base : long) : long
<>T78 = num ComparisonLessThan 0
If <>T78 Jump .T79
Jump .T80
.T79:
_ = Call print(-, 1)
<>T81 = ArithmeticNegation num
_ = Call printNum(<>T81)
Return 
.T80:
<>T82 = num Remainder base
_ = digit Assign <>T82
<>T83 = num Divide base
_ = rest Assign <>T83
<>T84 = rest ComparisonGreaterThan 0
If <>T84 Jump .T85
Jump .T86
.T85:
_ = Call printNumAny(rest, base)
.T86:
_ = Call printDigit(digit)

; proc printDigit(digit : long) : long
_ = digits Assign 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ
<>T88 = digit Multiply 2
<>T87 = digits Add <>T88
_ = Call print(<>T87, 1)

; proc print(ptr : ptr, len : long) : long
<>T90 = ArithmeticNegation 11
<>T89 = Call GetStdHandle(<>T90)
_ = stdOut Assign <>T89
_ = numberOfCharsWritten Assign 0
<>T92 = Reference numberOfCharsWritten
<>T91 = Call WriteConsoleW(stdOut, ptr, len, <>T92, 0)
Return <>T91
